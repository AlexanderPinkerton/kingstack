/**
 * Example demonstrating the new flexible optimistic defaults pattern
 * This shows how different entities can define their own optimistic behavior
 */

import {
  createOptimisticStore,
  OptimisticDefaults,
} from "@/lib/optimistic-store-pattern";

// ---------- Example 1: Simple Todo (minimal defaults) ----------

interface TodoApiData {
  id: string;
  title: string;
  done: boolean;
  user_id: string;
  created_at: string;
}

interface TodoUiData {
  id: string;
  title: string;
  done: boolean;
  user_id: string;
  created_at: Date;
  isNew: boolean; // computed field
}

// ✅ PREFERRED: Direct UI data creation - simple and efficient
const todoOptimisticDefaults: OptimisticDefaults<TodoApiData, TodoUiData> = {
  createOptimisticUiData: (userInput, context) => ({
    id: `temp-${Date.now()}`,
    title: userInput.title,
    done: userInput.done ?? false,
    user_id: context?.currentUser?.id || "unknown",
    created_at: new Date(), // Already a Date object for UI
    isNew: true, // Computed field - always true for new todos
  }),
};

// ---------- Example 2: Complex Product (rich defaults + pending fields) ----------

interface ProductApiData {
  id: string;
  name: string;
  description: string;
  price: number;
  category_id: string;
  sku: string; // Generated by server
  inventory_count: number; // Fetched from inventory service
  seo_score: number; // Computed by AI service
  moderation_status: "pending" | "approved" | "rejected";
  created_at: string;
}

interface ProductUiData {
  id: string;
  name: string;
  description: string;
  price: number;
  category_id: string;
  sku: string | null;
  inventory_count: number | null;
  seo_score: number | null;
  moderation_status: "pending" | "approved" | "rejected";
  created_at: Date;
  // UI-specific fields
  priceFormatted: string;
  isNew: boolean;
  isPending: boolean;
}

// ✅ PREFERRED: Direct UI data creation with pending fields
const productOptimisticDefaults: OptimisticDefaults<
  ProductApiData,
  ProductUiData
> = {
  createOptimisticUiData: (userInput, context) => ({
    id: `temp-${Date.now()}`,
    name: userInput.name,
    description: userInput.description,
    price: userInput.price,
    category_id: userInput.category_id,
    created_at: new Date(),
    // Server-generated fields marked as null (will show loading states)
    sku: null,
    inventory_count: null,
    seo_score: null,
    moderation_status: "pending",
    // UI computed fields
    priceFormatted: `$${userInput.price?.toFixed(2) || "0.00"}`,
    isNew: true,
    isPending: true, // Mark as pending until server confirms
  }),

  // These fields should show loading states instead of defaults
  pendingFields: ["sku", "inventory_count", "seo_score"],
};

// ---------- Example 3: Direct UI data creation (bypass transformer) ----------

interface NotificationUiData {
  id: string;
  title: string;
  message: string;
  type: "info" | "success" | "warning" | "error";
  timestamp: Date;
  isRead: boolean;
  isOptimistic: boolean;
}

// Create UI data directly (no API transformation needed)
const notificationOptimisticDefaults: OptimisticDefaults<
  any,
  NotificationUiData
> = {
  createOptimisticUiData: (userInput, context) => ({
    id: `temp-${Date.now()}`,
    title: userInput.title,
    message: userInput.message,
    type: userInput.type || "info",
    timestamp: new Date(),
    isRead: false,
    isOptimistic: true, // Mark as optimistic for special UI treatment
  }),
};

// ---------- Example 4: Context-dependent defaults ----------

interface CommentApiData {
  id: string;
  content: string;
  post_id: string;
  author_id: string;
  parent_id?: string;
  created_at: string;
  likes_count: number;
  author: {
    id: string;
    username: string;
    avatar_url: string;
  };
}

interface CommentUiData {
  id: string;
  content: string;
  post_id: string;
  author_id: string;
  parent_id?: string;
  created_at: Date;
  likes_count: number;
  author: {
    id: string;
    username: string;
    avatar_url: string;
    displayName: string;
  };
  isReply: boolean;
  depth: number;
}

// ✅ Context-aware optimistic UI data creation
const commentOptimisticDefaults: OptimisticDefaults<
  CommentApiData,
  CommentUiData
> = {
  createOptimisticUiData: (userInput, context) => {
    const { currentUser, postId, parentComment } = context || {};

    return {
      id: `temp-${Date.now()}`,
      content: userInput.content,
      post_id: postId || userInput.post_id,
      author_id: currentUser?.id || "unknown",
      parent_id: parentComment?.id, // For replies
      created_at: new Date(),
      likes_count: 0,
      author: {
        id: currentUser?.id || "unknown",
        username: currentUser?.username || "You",
        avatar_url: currentUser?.avatar_url || "/default-avatar.png",
        displayName: currentUser?.username || "You",
      },
      // UI computed fields
      isReply: !!parentComment,
      depth: parentComment ? (parentComment.depth || 0) + 1 : 0,
    };
  },
};

// ---------- Usage Examples ----------

export const FlexibleOptimisticExamples = () => {
  // Example 1: Simple todos with minimal defaults
  const useTodos = () =>
    createOptimisticStore({
      name: "todos",
      queryFn: () => fetch("/api/todos").then((r) => r.json()),
      mutations: {
        create: (data) =>
          fetch("/api/todos", {
            method: "POST",
            body: JSON.stringify(data),
          }).then((r) => r.json()),
        update: ({ id, data }) =>
          fetch(`/api/todos/${id}`, {
            method: "PUT",
            body: JSON.stringify(data),
          }).then((r) => r.json()),
        remove: (id) =>
          fetch(`/api/todos/${id}`, { method: "DELETE" }).then(() => ({ id })),
      },
      optimisticDefaults: todoOptimisticDefaults,
      optimisticContext: { currentUser: { id: "user1" } },
    })();

  // Example 2: Complex products with pending fields
  const useProducts = () =>
    createOptimisticStore({
      name: "products",
      queryFn: () => fetch("/api/products").then((r) => r.json()),
      mutations: {
        create: (data) =>
          fetch("/api/products", {
            method: "POST",
            body: JSON.stringify(data),
          }).then((r) => r.json()),
        update: ({ id, data }) =>
          fetch(`/api/products/${id}`, {
            method: "PUT",
            body: JSON.stringify(data),
          }).then((r) => r.json()),
        remove: (id) =>
          fetch(`/api/products/${id}`, { method: "DELETE" }).then(() => ({
            id,
          })),
      },
      optimisticDefaults: productOptimisticDefaults,
    })();

  // Example 3: Direct UI data creation
  const useNotifications = () =>
    createOptimisticStore({
      name: "notifications",
      queryFn: () => Promise.resolve([]), // Local only
      mutations: {
        create: (data) => Promise.resolve(data), // Local only
        update: ({ id, data }) => Promise.resolve({ id, ...data }),
        remove: (id) => Promise.resolve({ id }),
      },
      optimisticDefaults: notificationOptimisticDefaults,
      transformer: false, // No API transformation needed
    })();

  return (
    <div>
      <h2>Flexible Optimistic Defaults Examples</h2>

      <section>
        <h3>1. Simple Todos</h3>
        <p>Minimal defaults - just fills in missing server fields</p>
        {/* Todo UI would go here */}
      </section>

      <section>
        <h3>2. Complex Products</h3>
        <p>Rich defaults + pending fields for server-generated data</p>
        {/* Product UI would show loading states for pending fields */}
      </section>

      <section>
        <h3>3. Local Notifications</h3>
        <p>Direct UI data creation, bypassing API transformation</p>
        {/* Notification UI would go here */}
      </section>
    </div>
  );
};

// ---------- UI Helper for Pending Fields ----------

export const PendingField = ({
  value,
  children,
}: {
  value: any;
  children: React.ReactNode;
}) => {
  if (value === null || value === undefined) {
    return (
      <span className="animate-pulse bg-gray-200 rounded">Loading...</span>
    );
  }
  return <>{children}</>;
};

// Example usage:
// <PendingField value={product.sku}>
//   <span>SKU: {product.sku}</span>
// </PendingField>
