import { existsSync, mkdirSync, renameSync, writeFileSync, readFileSync } from "fs";
import { dirname, join, resolve } from "path";
import * as TOML from "@iarna/toml";
import { resolveConfig, validateEnvFileKeys } from "../core";
import { loadUserSchema, loadUserValues } from "./utils";

export async function generateCommand(env: string, options: { cwd?: string }) {
    const cwd = options.cwd ? resolve(options.cwd) : process.cwd();
    console.log(`üîß Generating configuration for environment: ${env} (in ${cwd})\n`);

    try {
        const schema = await loadUserSchema(cwd);
        const values = await loadUserValues(env, cwd);

        // Resolve all configuration (core + computed)
        const { config, errors } = resolveConfig(schema, values);

        if (errors.length > 0) {
            console.error("‚ùå Validation errors:");
            for (const error of errors) {
                console.error(`  - ${error.key}: ${error.message}`);
            }
            process.exit(1);
        }

        // Validate envfile keys
        const allKeys = new Set([
            ...Object.keys(config.core),
            ...Object.keys(config.computed),
        ]);
        const envfileErrors = validateEnvFileKeys(schema, allKeys);

        if (envfileErrors.length > 0) {
            console.error("‚ùå Environment file configuration errors:");
            for (const error of envfileErrors) {
                console.error(`  - ${error.key}: ${error.message}`);
            }
            process.exit(1);
        }

        console.log("‚úÖ Validation passed\n");

        // Generate .env files
        console.log("üìÑ Generating .env files...\n");
        for (const [envfileName, envfileConfig] of Object.entries(schema.envfiles)) {
            const destPath = resolve(cwd, envfileConfig.path);
            const destDir = dirname(destPath);

            if (!existsSync(destDir)) {
                mkdirSync(destDir, { recursive: true });
            }

            if (existsSync(destPath)) {
                renameSync(destPath, `${destPath}.previous`);
                console.log(`üì¶ Backed up ${envfileConfig.path} to .previous`);
            }

            const lines: string[] = [];
            lines.push(`# Generated from config/${env}.ts`);
            lines.push(`# DO NOT EDIT THIS FILE DIRECTLY - edit config/${env}.ts instead`);
            lines.push("");

            for (const key of envfileConfig.keys) {
                const value = config.all[key];
                if (value !== undefined) {
                    const needsQuotes = value.includes(" ") || value.includes("#");
                    lines.push(`${key}=${needsQuotes ? `"${value}"` : value}`);
                }
            }

            if (envfileConfig.aliases) {
                for (const [sourceKey, targetKey] of Object.entries(envfileConfig.aliases)) {
                    const value = config.all[sourceKey];
                    if (value !== undefined) {
                        const needsQuotes = value.includes(" ") || value.includes("#");
                        lines.push(`${targetKey}=${needsQuotes ? `"${value}"` : value}`);
                    }
                }
            }

            writeFileSync(destPath, lines.join("\n") + "\n");
            console.log(`‚úÖ Generated ${envfileConfig.path}`);
        }

        // Update config files
        if (schema.configs) {
            console.log("\nüìù Updating config files...\n");
            for (const [configName, configDef] of Object.entries(schema.configs)) {
                const configPath = resolve(cwd, configDef.path);

                if (!existsSync(configPath)) {
                    console.log(`‚ö†Ô∏è  Skipping ${configDef.path} (file does not exist)`);
                    continue;
                }

                renameSync(configPath, `${configPath}.previous`);

                if (configDef.format === "toml") {
                    const tomlContent = readFileSync(`${configPath}.previous`, "utf-8");
                    const parsed = TOML.parse(tomlContent) as any;

                    let updatedCount = 0;
                    for (const [tomlPath, configKey] of Object.entries(configDef.mappings)) {
                        const value = config.all[configKey];
                        if (value !== undefined) {
                            const shouldBeNumber = tomlPath.includes("port") || tomlPath.includes("Port");
                            const finalValue = shouldBeNumber ? Number(value) : value;
                            setNestedValue(parsed, tomlPath, finalValue);
                            updatedCount++;
                        }
                    }

                    const updatedToml = stringifyTomlWithoutUnderscores(parsed);
                    writeFileSync(configPath, updatedToml);
                    console.log(`‚úÖ Updated ${configDef.path}`);
                }
            }
        }

        console.log(`\nüéâ Successfully generated configuration for ${env} environment!`);

    } catch (error: any) {
        console.error(`‚ùå Error: ${error.message}`);
        process.exit(1);
    }
}

function setNestedValue(obj: any, path: string, value: any): void {
    const keys = path.split(".");
    let current = obj;
    for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (!(key in current)) {
            current[key] = {};
        }
        current = current[key];
    }
    current[keys[keys.length - 1]] = value;
}

function stringifyTomlWithoutUnderscores(obj: any): string {
    const tomlString = TOML.stringify(obj);
    return tomlString.replace(/(\d)_(\d)/g, '$1$2');
}
