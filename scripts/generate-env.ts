/**
 * generate-env.ts
 * 
 * Generates .env files from the TypeScript secrets configuration.
 * 
 * Usage:
 *   bun scripts/generate-env.ts [environment]
 *   bun scripts/generate-env.ts local
 *   bun scripts/generate-env.ts development
 *   bun scripts/generate-env.ts production
 *   bun scripts/generate-env.ts playground
 */

import { existsSync, readFileSync, writeFileSync, renameSync, mkdirSync } from "fs";
import { dirname, join } from "path";
import { schema } from "../secrets/schema";
import { resolveSecrets, validateProjectKeys } from "../secrets/utils";

const ENVIRONMENTS = ["local", "development", "production", "playground"];

async function main() {
    const envArg = process.argv[2];

    if (!envArg) {
        printUsageAndExit();
    }

    if (!ENVIRONMENTS.includes(envArg)) {
        console.error(`âŒ Unknown environment: ${envArg}`);
        printUsageAndExit();
    }

    console.log(`ğŸ”§ Generating .env files for environment: ${envArg}\n`);

    // Load the values file for this environment
    const valuesPath = join("secrets", `${envArg}.ts`);
    if (!existsSync(valuesPath)) {
        console.error(`âŒ Error: ${valuesPath} does not exist.`);
        console.error(`\nğŸ’¡ Tip: Copy secrets/example.ts to ${valuesPath} and fill in your values.`);
        process.exit(1);
    }

    // Dynamically import the values
    let values;
    try {
        const imported = await import(`../${valuesPath}`);
        values = imported.values;
    } catch (error) {
        console.error(`âŒ Error loading ${valuesPath}:`, error);
        process.exit(1);
    }

    // Resolve all secrets (core + computed)
    const { secrets, errors } = resolveSecrets(schema, values);

    if (errors.length > 0) {
        console.error("âŒ Validation errors:");
        for (const error of errors) {
            console.error(`  - ${error.key}: ${error.message}`);
        }
        process.exit(1);
    }

    // Validate project keys
    const allKeys = new Set([
        ...Object.keys(secrets.core),
        ...Object.keys(secrets.computed),
    ]);
    const projectErrors = validateProjectKeys(schema, allKeys);

    if (projectErrors.length > 0) {
        console.error("âŒ Project configuration errors:");
        for (const error of projectErrors) {
            console.error(`  - ${error.key}: ${error.message}`);
        }
        process.exit(1);
    }

    console.log("âœ… Validation passed\n");

    // Generate .env files for each project
    for (const [projectName, config] of Object.entries(schema.projects)) {
        const destPath = config.path;
        const destDir = dirname(destPath);

        // Ensure directory exists
        if (!existsSync(destDir)) {
            mkdirSync(destDir, { recursive: true });
        }

        // Backup existing file
        if (existsSync(destPath)) {
            const backupPath = `${destPath}.previous`;
            renameSync(destPath, backupPath);
            console.log(`ğŸ“¦ Backed up ${destPath} to ${backupPath}`);
        }

        // Build .env content
        const lines: string[] = [];
        lines.push(`# Generated from secrets/${envArg}.ts`);
        lines.push(`# DO NOT EDIT THIS FILE DIRECTLY - edit secrets/${envArg}.ts instead`);
        lines.push("");

        // Add direct keys
        for (const key of config.keys) {
            const value = secrets.all[key];
            if (value !== undefined) {
                // Quote values that contain spaces or special characters
                const needsQuotes = value.includes(" ") || value.includes("#");
                lines.push(`${key}=${needsQuotes ? `"${value}"` : value}`);
            }
        }

        // Add aliased keys (source key â†’ target key name)
        if (config.aliases) {
            for (const [sourceKey, targetKey] of Object.entries(config.aliases)) {
                const value = secrets.all[sourceKey];
                if (value !== undefined) {
                    const needsQuotes = value.includes(" ") || value.includes("#");
                    lines.push(`${targetKey}=${needsQuotes ? `"${value}"` : value}`);
                }
            }
        }

        // Write the file
        writeFileSync(destPath, lines.join("\n") + "\n");
        const totalKeys = config.keys.length + (config.aliases ? Object.keys(config.aliases).length : 0);
        console.log(`âœ… Generated ${destPath} (${totalKeys} keys)`);
    }

    console.log(`\nğŸ‰ Successfully generated .env files for ${envArg} environment!`);
}

function printUsageAndExit() {
    console.error("Usage:");
    console.error("  bun scripts/generate-env.ts [local|development|production|playground]");
    process.exit(1);
}

main().catch((err) => {
    console.error("âŒ Fatal error:", err);
    process.exit(1);
});
