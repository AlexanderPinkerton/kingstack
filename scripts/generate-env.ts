/**
 * generate-env.ts
 * 
 * Generates .env files and updates config files from the TypeScript configuration.
 * 
 * Usage:
 *   bun scripts/generate-env.ts [environment]
 *   bun scripts/generate-env.ts local
 *   bun scripts/generate-env.ts development
 *   bun scripts/generate-env.ts production
 *   bun scripts/generate-env.ts playground
 */

import { existsSync, readFileSync, writeFileSync, renameSync, mkdirSync } from "fs";
import { dirname, join } from "path";
import * as TOML from "@iarna/toml";
import { schema } from "../config/schema";
import { resolveConfig, validateEnvFileKeys } from "../config/utils";

const ENVIRONMENTS = ["local", "development", "production", "playground"];

async function main() {
    const envArg = process.argv[2];

    if (!envArg) {
        printUsageAndExit();
    }

    if (!ENVIRONMENTS.includes(envArg)) {
        console.error(`‚ùå Unknown environment: ${envArg}`);
        printUsageAndExit();
    }

    console.log(`üîß Generating configuration for environment: ${envArg}\n`);

    // Load the values file for this environment
    const valuesPath = join("config", `${envArg}.ts`);
    if (!existsSync(valuesPath)) {
        console.error(`‚ùå Error: ${valuesPath} does not exist.`);
        console.error(`\nüí° Tip: Copy config/example.ts to ${valuesPath} and fill in your values.`);
        process.exit(1);
    }

    // Dynamically import the values
    let values;
    try {
        const imported = await import(`../${valuesPath}`);
        values = imported.values;
    } catch (error) {
        console.error(`‚ùå Error loading ${valuesPath}:`, error);
        process.exit(1);
    }

    // Resolve all configuration (core + computed)
    const { config, errors } = resolveConfig(schema, values);

    if (errors.length > 0) {
        console.error("‚ùå Validation errors:");
        for (const error of errors) {
            console.error(`  - ${error.key}: ${error.message}`);
        }
        process.exit(1);
    }

    // Validate envfile keys
    const allKeys = new Set([
        ...Object.keys(config.core),
        ...Object.keys(config.computed),
    ]);
    const envfileErrors = validateEnvFileKeys(schema, allKeys);

    if (envfileErrors.length > 0) {
        console.error("‚ùå Environment file configuration errors:");
        for (const error of envfileErrors) {
            console.error(`  - ${error.key}: ${error.message}`);
        }
        process.exit(1);
    }

    console.log("‚úÖ Validation passed\n");

    // Generate .env files for each environment file
    console.log("üìÑ Generating .env files...\n");
    for (const [envfileName, envfileConfig] of Object.entries(schema.envfiles)) {
        const destPath = envfileConfig.path;
        const destDir = dirname(destPath);

        // Ensure directory exists
        if (!existsSync(destDir)) {
            mkdirSync(destDir, { recursive: true });
        }

        // Backup existing file
        if (existsSync(destPath)) {
            const backupPath = `${destPath}.previous`;
            renameSync(destPath, backupPath);
            console.log(`üì¶ Backed up ${destPath} to ${backupPath}`);
        }

        // Build .env content
        const lines: string[] = [];
        lines.push(`# Generated from config/${envArg}.ts`);
        lines.push(`# DO NOT EDIT THIS FILE DIRECTLY - edit config/${envArg}.ts instead`);
        lines.push("");

        // Add direct keys
        for (const key of envfileConfig.keys) {
            const value = config.all[key];
            if (value !== undefined) {
                // Quote values that contain spaces or special characters
                const needsQuotes = value.includes(" ") || value.includes("#");
                lines.push(`${key}=${needsQuotes ? `"${value}"` : value}`);
            }
        }

        // Add aliased keys (source key ‚Üí target key name)
        if (envfileConfig.aliases) {
            for (const [sourceKey, targetKey] of Object.entries(envfileConfig.aliases)) {
                const value = config.all[sourceKey];
                if (value !== undefined) {
                    const needsQuotes = value.includes(" ") || value.includes("#");
                    lines.push(`${targetKey}=${needsQuotes ? `"${value}"` : value}`);
                }
            }
        }

        // Write the file
        writeFileSync(destPath, lines.join("\n") + "\n");
        const totalKeys = envfileConfig.keys.length + (envfileConfig.aliases ? Object.keys(envfileConfig.aliases).length : 0);
        console.log(`‚úÖ Generated ${destPath} (${totalKeys} keys)`);
    }

    // Update config files
    if (schema.configs) {
        console.log("\nüìù Updating config files...\n");

        for (const [configName, configDef] of Object.entries(schema.configs)) {
            const configPath = configDef.path;

            if (!existsSync(configPath)) {
                console.log(`‚ö†Ô∏è  Skipping ${configPath} (file does not exist)`);
                continue;
            }

            // Backup existing file
            const backupPath = `${configPath}.previous`;
            renameSync(configPath, backupPath);
            console.log(`üì¶ Backed up ${configPath} to ${backupPath}`);

            if (configDef.format === "toml") {
                // Parse existing TOML
                const tomlContent = readFileSync(backupPath, "utf-8");
                const parsed = TOML.parse(tomlContent) as any;

                // Update mapped values
                let updatedCount = 0;
                for (const [tomlPath, configKey] of Object.entries(configDef.mappings)) {
                    const value = config.all[configKey];
                    if (value !== undefined) {
                        // Determine if this should be a number or string based on the TOML path
                        const shouldBeNumber = tomlPath.includes("port") || tomlPath.includes("Port");
                        const finalValue = shouldBeNumber ? Number(value) : value;
                        setNestedValue(parsed, tomlPath, finalValue);
                        updatedCount++;
                    }
                }

                // Write back with custom stringification to avoid underscores in numbers
                const updatedToml = stringifyTomlWithoutUnderscores(parsed);
                writeFileSync(configPath, updatedToml);
                console.log(`‚úÖ Updated ${configPath} (${updatedCount} values)`);
            } else {
                console.log(`‚ö†Ô∏è  Skipping ${configPath} (format ${configDef.format} not yet supported)`);
            }
        }
    }

    console.log(`\nüéâ Successfully generated configuration for ${envArg} environment!`);
}

/**
 * Sets a nested value in an object using dot notation.
 * Example: setNestedValue(obj, "db.pooler.port", 5432)
 */
function setNestedValue(obj: any, path: string, value: any): void {
    const keys = path.split(".");
    let current = obj;

    for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (!(key in current)) {
            current[key] = {};
        }
        current = current[key];
    }

    current[keys[keys.length - 1]] = value;
}

/**
 * Stringify TOML without underscores in numbers.
 * The @iarna/toml library adds underscores to large numbers, which we don't want.
 */
function stringifyTomlWithoutUnderscores(obj: any): string {
    const tomlString = TOML.stringify(obj);
    // Remove underscores from numbers (e.g., 54_321 -> 54321, 1_000 -> 1000)
    return tomlString.replace(/(\d)_(\d)/g, '$1$2');
}

function printUsageAndExit() {
    console.error("Usage:");
    console.error("  bun scripts/generate-env.ts [local|development|production|playground]");
    process.exit(1);
}

main().catch((err) => {
    console.error("‚ùå Fatal error:", err);
    process.exit(1);
});
