# ğŸ” Secrets Management

KingStack uses an **explicit secrets management system** to avoid common pitfalls with dotenv detection and environment variable management.

## The Problem

Traditional `.env` file management often leads to:
- âŒ Unclear which environment is active
- âŒ Scattered `.env` files across the monorepo
- âŒ Accidental commits of secrets
- âŒ Difficult to switch between environments
- âŒ No clear backup of previous configurations

## The Solution

All secrets are organized in a centralized `secrets/` directory:

```
secrets/
â”œâ”€â”€ development/
â”‚   â”œâ”€â”€ .env.next      # Next.js environment variables
â”‚   â”œâ”€â”€ .env.nest      # NestJS environment variables
â”‚   â””â”€â”€ .env.prisma    # Prisma database connection
â”œâ”€â”€ production/
â”‚   â”œâ”€â”€ .env.next
â”‚   â”œâ”€â”€ .env.nest
â”‚   â””â”€â”€ .env.prisma
â””â”€â”€ playground/
    â””â”€â”€ (auto-generated by setup script)
```

## Usage

### Switch Environments

```bash
# Switch to development
yarn env:development
# or
bun scripts/swap-env.ts development

# Switch to production
yarn env:production
# or
bun scripts/swap-env.ts production

# Setup playground mode (creates mock env files)
yarn env:playground
# or
bun scripts/setup-playground.ts
```

### Check Current Environment

```bash
yarn env:current
# or
bun scripts/swap-env.ts --current
```

This compares the active `.env` files in `apps/next/`, `apps/nest/`, and `packages/prisma/` against the source files in `secrets/` to determine which environment is active.

## How It Works

1. **Source of Truth**: Environment files live in `secrets/[environment]/`
2. **Swap Process**: The swap script copies files to their destinations:
   - `secrets/development/.env.next` â†’ `apps/next/.env`
   - `secrets/development/.env.nest` â†’ `apps/nest/.env`
   - `secrets/development/.env.prisma` â†’ `packages/prisma/.env`
3. **Backup**: Previous `.env` files are backed up as `.env.previous` before swapping
4. **Detection**: Current environment is detected by comparing file contents

## Benefits

âœ… **Explicit** - You always know which environment is active  
âœ… **Centralized** - All secrets in one place  
âœ… **Safe** - Previous configs are backed up  
âœ… **Simple** - One command to switch environments  
âœ… **Clear** - Easy to see what's different between environments  

## Setup

1. Create environment directories:
   ```bash
   mkdir -p secrets/development
   mkdir -p secrets/production
   ```

2. Add your environment files:
   ```bash
   # Copy your existing .env files to secrets/
   cp apps/next/.env secrets/development/.env.next
   cp apps/nest/.env secrets/development/.env.nest
   cp packages/prisma/.env secrets/development/.env.prisma
   ```

3. Update `.gitignore` to exclude active `.env` files but track secrets:
   ```gitignore
   # Active environment files (not tracked)
   apps/next/.env
   apps/nest/.env
   packages/prisma/.env
   
   # Backup files (not tracked)
   **/.env.previous
   
   # Secrets directory IS tracked (use GitHub Secrets for sensitive values)
   # secrets/
   ```

## Best Practices

1. **Never commit secrets directly** - Use GitHub Secrets for CI/CD
2. **Use `.env.example` files** - Document required variables
3. **Keep secrets organized** - One file per service per environment
4. **Test environment switching** - Verify swaps work correctly
5. **Document required variables** - Keep a list of what each service needs

## Example: Required Variables

### Next.js (`.env.next`)
```env
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
NEXT_PUBLIC_NEST_URL=
NEXT_PUBLIC_API_URL=
```

### NestJS (`.env.nest`)
```env
SUPABASE_URL=
SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=
SUPA_JWT_SECRET=
SUPABASE_DB_POOL_URL=
SUPABASE_DB_DIRECT_URL=
```

### Prisma (`.env.prisma`)
```env
SUPABASE_DB_POOL_URL=
SUPABASE_DB_DIRECT_URL=
```

